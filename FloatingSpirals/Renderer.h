#pragma once
#include <SFML/Graphics.hpp>
using namespace sf;

#include "lib/delaunator.h"

class Renderer {
private:
    RenderWindow* window;
    std::vector<float> getCoords(std::vector<ParticleSim::Particle> particles) {
        std::vector<float> coords;
        coords.reserve(particles.size() * 2);
        for (int i = 0; i < particles.size(); i++) {
            coords.emplace_back(particles[i].pos.x);
            coords.emplace_back(particles[i].pos.y);
        }
        return coords;
    }
    inline float dist(const Vector2f& a, const Vector2f& b) {
        return sqrtf(((a.x - b.x) * (a.x - b.x)) + ((a.y - b.y) * (a.y - b.y)));
    }
    inline float distSquared(const Vector2f& p1, const Vector2f& p2) {
        // Distance between two points without the square root (helps performance)
        // ((x2-x1)^2 + (y1-y2)^2)
        return ((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y));
    }
    // https://www.tutorialspoint.com/program-for-point-of-intersection-of-two-lines-in-cplusplus
    inline Vector2f intersection(Vector2f A, Vector2f B, Vector2f C, Vector2f D) {
        // Line AB represented as a1x + b1y = c1
        double a = B.y - A.y;
        double b = A.x - B.x;
        double c = a * (A.x) + b * (A.y);
        // Line CD represented as a2x + b2y = c2
        double a1 = D.y - C.y;
        double b1 = C.x - D.x;
        double c1 = a1 * (C.x) + b1 * (C.y);
        double det = a * b1 - a1 * b;
        double x = (b1 * c - b * c1) / det;
        double y = (a * c1 - a1 * c) / det;
        return Vector2f(x, y);
    }
    inline float lerp(float a, float b, float t) {
        return a + t * (b - a);
    }
    inline Vector2f lerpPoint(Vector2f a, Vector2f b, float t) {
        return Vector2f(lerp(a.x, b.x, t), lerp(a.y, b.y, t));
    }
public:
    Renderer(RenderWindow* window) {
        this->window = window;
    }

    void render(const std::vector<ParticleSim::Particle>& particles) {
        std::vector<float> coords = getCoords(particles);
        delaunator::Delaunator d(coords);


        float distanceSquared = 1000000.f;
        std::vector<Vertex> vertices;
        // Iterate over triangles generated by delaunator
        for (int i = 0; i < d.triangles.size(); i += 3) {
            // Organize points of each triangle into something easier to work with
            Vector2f points[3] = {
                Vector2f(d.coords[2 * d.triangles[i]], d.coords[2 * d.triangles[i] + 1]),
                Vector2f(d.coords[2 * d.triangles[i + 1]], d.coords[2 * d.triangles[i + 1] + 1]),
                Vector2f(d.coords[2 * d.triangles[i + 2]], d.coords[2 * d.triangles[i + 2] + 1])
            };


            // Get distance of all lines
            float line1 = distSquared(points[0], points[1]);
            float line2 = distSquared(points[1], points[2]);
            float line3 = distSquared(points[2], points[0]);

            // Get the largest line
            float triangleLargestDist = fmaxf(line1, fmaxf(line2, line3));

            // If the largest line is over the max distance, skip the entire triangle
            // (If we only skipped the largest line, it would lead to open triangles)
            if (triangleLargestDist > distanceSquared) {
                // TODO - Need to remove this when done testing spiral algorithm
                continue;
            }

            // Line 1
            vertices.push_back(Vertex(points[0], Color::White));
            vertices.push_back(Vertex(points[1], Color::White));

            // Line 2
            vertices.push_back(Vertex(points[1], Color::White));
            vertices.push_back(Vertex(points[2], Color::White));

            // Line 3
            vertices.push_back(Vertex(points[2], Color::White));
            vertices.push_back(Vertex(points[0], Color::White));
        }

        int iterations = 64;
        float t = 1.f / 16.f;

        CircleShape c(50.f);

        // go over each triangle and apply spiral algorithm
        for (int i = 0; i < d.triangles.size(); i += 3) {
            // Organize points of each triangle into something easier to work with
            Vector2f points[3] = {
                Vector2f(d.coords[2 * d.triangles[i]], d.coords[2 * d.triangles[i] + 1]),
                Vector2f(d.coords[2 * d.triangles[i + 1]], d.coords[2 * d.triangles[i + 1] + 1]),
                Vector2f(d.coords[2 * d.triangles[i + 2]], d.coords[2 * d.triangles[i + 2] + 1])
            };

            // Get distance of all lines
            float line1 = distSquared(points[0], points[1]);
            float line2 = distSquared(points[1], points[2]);
            float line3 = distSquared(points[2], points[0]);

            // Get the largest line
            float triangleLargestDist = fmaxf(line1, fmaxf(line2, line3));

            // If the largest line is over the max distance, skip the entire triangle
            // (If we only skipped the largest line, it would lead to open triangles)
            if (triangleLargestDist > distanceSquared) {
                // TODO - Need to remove this when done testing spiral algorithm
                continue;
            }

            for (int j = 0; j < iterations; j++) {
                // Take first line
                Vector2f p1 = points[0];
                // Get point on second line at t
                Vector2f p2 = lerpPoint(points[1], points[2], t);
                // Add line to lines
                Color p12c = Color::White;
                vertices.push_back(Vertex(p1, p12c));
                vertices.push_back(Vertex(p2, p12c));

                // start at p2 and go to midpoint on line 2-3?
                Vector2f p3 = p2;
                Vector2f p4 = lerpPoint(points[2], points[0], t);
                Color p34c = Color::White;
                vertices.push_back(Vertex(p3, p34c));
                vertices.push_back(Vertex(p4, p34c));

                Vector2f p5 = p4;
                Vector2f p6 = lerpPoint(p1, p2, t);
                Color p56c = Color::White;
                vertices.push_back(Vertex(p5, p56c));
                vertices.push_back(Vertex(p6, p56c));

                points[0] = p2;
                points[1] = p4;
                points[2] = p6;
            }
        }

        window->draw(&vertices[0], vertices.size(), PrimitiveType::Lines);

        CircleShape cs;
        cs.setRadius(5.f);
        for (int i = 0; i < particles.size(); i++) {
            cs.setPosition(particles[i].pos.x, particles[i].pos.y);
            //window->draw(cs);
        }

    }
};